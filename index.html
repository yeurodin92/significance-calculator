<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>A/B Test Results Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 30px;
        text-align: center;
      }

      .header h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        font-weight: 300;
      }

      .header p {
        font-size: 1.1rem;
        opacity: 0.9;
      }

      .content {
        padding: 40px;
      }

      .metric-selector {
        background: #f0f4f8;
        border-radius: 15px;
        padding: 25px;
        margin-bottom: 30px;
        border: 2px solid #e2e8f0;
      }

      .metric-selector h3 {
        color: #2d3748;
        margin-bottom: 20px;
        font-size: 1.3rem;
      }

      .metric-tabs {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
      }

      .metric-tab {
        padding: 12px 24px;
        border: 2px solid #e2e8f0;
        border-radius: 10px;
        background: white;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 500;
      }

      .metric-tab.active {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: #667eea;
      }

      .metric-tab:hover:not(.active) {
        border-color: #667eea;
        background: #f7fafc;
      }

      .metric-description {
        color: #4a5568;
        font-size: 0.9rem;
        margin-top: 10px;
        padding: 12px;
        background: white;
        border-radius: 8px;
        border-left: 4px solid #667eea;
      }

      .input-fields {
        display: none !important;
      }

      .input-fields.active {
        display: block !important;
      }

      .input-section {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        margin-bottom: 40px;
      }

      .variant-card {
        background: #f8fafc;
        border-radius: 15px;
        padding: 25px;
        border: 2px solid #e2e8f0;
        transition: all 0.3s ease;
      }

      .variant-card:hover {
        border-color: #667eea;
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.1);
      }

      .variant-card h3 {
        color: #2d3748;
        margin-bottom: 20px;
        font-size: 1.3rem;
        display: flex;
        align-items: center;
      }

      .variant-icon {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        margin-right: 10px;
      }

      .control-icon {
        background: #e53e3e;
      }

      .variant-icon-b {
        background: #38a169;
      }

      .input-group {
        margin-bottom: 20px;
      }

      .input-group label {
        display: block;
        margin-bottom: 8px;
        color: #4a5568;
        font-weight: 500;
      }

      .input-group input {
        width: 100%;
        padding: 12px 15px;
        border: 2px solid #e2e8f0;
        border-radius: 10px;
        font-size: 1rem;
        transition: border-color 0.3s ease;
      }

      .input-group input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      .analyze-btn {
        width: 100%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 15px 30px;
        border-radius: 12px;
        font-size: 1.1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-bottom: 30px;
      }

      .analyze-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
      }

      .results {
        display: none;
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .results-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .result-card {
        background: #f7fafc;
        border-radius: 15px;
        padding: 25px;
        border-left: 5px solid #667eea;
      }

      .result-card h4 {
        color: #2d3748;
        margin-bottom: 15px;
        font-size: 1.2rem;
      }

      .metric {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
      }

      .metric-label {
        color: #4a5568;
      }

      .metric-value {
        font-weight: 600;
        color: #2d3748;
      }

      .significance-badge {
        display: inline-block;
        padding: 8px 16px;
        border-radius: 20px;
        font-weight: 600;
        font-size: 0.9rem;
        margin-top: 10px;
      }

      .significant {
        background: #c6f6d5;
        color: #22543d;
      }

      .not-significant {
        background: #fed7d7;
        color: #742a2a;
      }

      .warning {
        background: #fef5e7;
        color: #744210;
      }

      .reliability-section {
        background: #edf2f7;
        border-radius: 15px;
        padding: 25px;
        margin-top: 20px;
      }

      .reliability-section h4 {
        color: #2d3748;
        margin-bottom: 15px;
        font-size: 1.2rem;
      }

      .reliability-item {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }

      .reliability-icon {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        margin-right: 10px;
      }

      .check {
        background: #38a169;
      }

      .warning-icon {
        background: #d69e2e;
      }

      .error-icon {
        background: #e53e3e;
      }

      .footer {
        text-align: center;
        padding: 20px;
        color: #718096;
        border-top: 1px solid #e2e8f0;
      }

      .visualization-section {
        margin-top: 30px;
        background: #f7fafc;
        border-radius: 15px;
        padding: 25px;
      }

      .visualization-section h4 {
        color: #2d3748;
        margin-bottom: 20px;
        font-size: 1.3rem;
      }

      .chart-container {
        position: relative;
        height: 300px;
        margin-bottom: 20px;
        background: white;
        border-radius: 10px;
        padding: 15px;
      }

      .charts-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>A/B Test Results Analyzer</h1>
        <p>
          Analyze your test results for statistical significance and data
          reliability
        </p>
      </div>

      <div class="content">
        <div class="metric-selector">
          <h3>Select Analysis Method</h3>
          <div class="metric-tabs">
            <div
              class="metric-tab active"
              onclick="switchAnalysisMethod('frequentist')"
            >
              Frequentist (Classic)
            </div>
            <div class="metric-tab" onclick="switchAnalysisMethod('bayesian')">
              Bayesian
            </div>
          </div>
          <div id="frequentist-description" class="metric-description">
            <strong>Frequentist Analysis:</strong> Traditional hypothesis testing with p-values and confidence intervals. Reports statistical significance at α=0.05.
          </div>
          <div
            id="bayesian-description"
            class="metric-description"
            style="display: none"
          >
            <strong>Bayesian Analysis:</strong> Calculates probability that variant is better, expected loss, and credible intervals. More intuitive interpretation.
          </div>
        </div>

        <div class="metric-selector" style="margin-top: 20px;">
          <h3>Select Metric Type</h3>
          <div class="metric-tabs">
            <div
              class="metric-tab active"
              onclick="switchMetricType('conversion')"
            >
              Conversion Rate
            </div>
            <div class="metric-tab" onclick="switchMetricType('continuous')">
              Continuous (AOV, Revenue)
            </div>
          </div>
          <div id="conversion-description" class="metric-description">
            <strong>Conversion Rate:</strong> Use for binary outcomes
            like conversions, sign-ups, or clicks.
          </div>
          <div
            id="continuous-description"
            class="metric-description"
            style="display: none"
          >
            <strong>Continuous Metric:</strong> Use for numerical
            metrics like Average Order Value, Revenue per User, or Session
            Duration.
          </div>
        </div>

        <div id="conversion-inputs" class="input-section input-fields active">
          <div class="variant-card">
            <h3><span class="variant-icon control-icon"></span>Control (A)</h3>
            <div class="input-group">
              <label for="control-visitors">Visitors</label>
              <input
                type="number"
                id="control-visitors"
                placeholder="e.g., 1000"
              />
            </div>
            <div class="input-group">
              <label for="control-conversions">Conversions</label>
              <input
                type="number"
                id="control-conversions"
                placeholder="e.g., 50"
              />
            </div>
          </div>

          <div class="variant-card">
            <h3>
              <span class="variant-icon variant-icon-b"></span>Variant (B)
            </h3>
            <div class="input-group">
              <label for="variant-visitors">Visitors</label>
              <input
                type="number"
                id="variant-visitors"
                placeholder="e.g., 1000"
              />
            </div>
            <div class="input-group">
              <label for="variant-conversions">Conversions</label>
              <input
                type="number"
                id="variant-conversions"
                placeholder="e.g., 65"
              />
            </div>
          </div>
        </div>

        <div id="continuous-inputs" class="input-section input-fields">
          <div class="variant-card">
            <h3><span class="variant-icon control-icon"></span>Control (A)</h3>
            <div class="input-group">
              <label for="control-sample-size">Sample Size</label>
              <input
                type="number"
                id="control-sample-size"
                placeholder="e.g., 1000"
              />
            </div>
            <div class="input-group">
              <label for="control-mean">Mean Value</label>
              <input
                type="number"
                id="control-mean"
                step="0.01"
                placeholder="e.g., 45.50"
              />
            </div>
            <div class="input-group">
              <label for="control-std">Standard Deviation</label>
              <input
                type="number"
                id="control-std"
                step="0.01"
                placeholder="e.g., 12.30"
              />
            </div>
          </div>

          <div class="variant-card">
            <h3>
              <span class="variant-icon variant-icon-b"></span>Variant (B)
            </h3>
            <div class="input-group">
              <label for="variant-sample-size">Sample Size</label>
              <input
                type="number"
                id="variant-sample-size"
                placeholder="e.g., 1000"
              />
            </div>
            <div class="input-group">
              <label for="variant-mean">Mean Value</label>
              <input
                type="number"
                id="variant-mean"
                step="0.01"
                placeholder="e.g., 48.75"
              />
            </div>
            <div class="input-group">
              <label for="variant-std">Standard Deviation</label>
              <input
                type="number"
                id="variant-std"
                step="0.01"
                placeholder="e.g., 13.10"
              />
            </div>
          </div>
        </div>

        <button class="analyze-btn" onclick="analyzeResults()">
          Analyze Results
        </button>

        <div id="results" class="results">
          <div class="results-grid">
            <div class="result-card">
              <h4 id="primary-metric-title">Conversion Rates</h4>
              <div class="metric">
                <span class="metric-label" id="control-label"
                  >Control (A):</span
                >
                <span class="metric-value" id="control-rate">-</span>
              </div>
              <div class="metric">
                <span class="metric-label" id="variant-label"
                  >Variant (B):</span
                >
                <span class="metric-value" id="variant-rate">-</span>
              </div>
              <div class="metric">
                <span class="metric-label">Relative Improvement:</span>
                <span class="metric-value" id="improvement">-</span>
              </div>
              <div class="metric" id="effect-size-metric" style="display: none">
                <span class="metric-label">Effect Size (Cohen's d):</span>
                <span class="metric-value" id="effect-size">-</span>
              </div>
            </div>

            <div class="result-card">
              <h4>Statistical Analysis</h4>
              <div class="metric">
                <span class="metric-label">P-value:</span>
                <span class="metric-value" id="p-value">-</span>
              </div>
              <div class="metric">
                <span class="metric-label" id="test-statistic-label"
                  >Z-score:</span
                >
                <span class="metric-value" id="z-score">-</span>
              </div>
              <div class="metric" id="degrees-freedom" style="display: none">
                <span class="metric-label">Degrees of Freedom:</span>
                <span class="metric-value" id="df">-</span>
              </div>
              <div class="metric">
                <span class="metric-label">Confidence Interval:</span>
                <span class="metric-value" id="confidence-interval">-</span>
              </div>
              <div id="significance-badge"></div>
            </div>

            <div class="result-card">
              <h4>Sample Size & Power</h4>
              <div class="metric">
                <span class="metric-label">Total Sample Size:</span>
                <span class="metric-value" id="total-sample">-</span>
              </div>
              <div class="metric">
                <span class="metric-label">Statistical Power:</span>
                <span class="metric-value" id="statistical-power">-</span>
              </div>
              <div class="metric">
                <span class="metric-label">Minimum Detectable Effect:</span>
                <span class="metric-value" id="mde">-</span>
              </div>
            </div>
          </div>

          <div class="reliability-section">
            <h4>Data Reliability Checks</h4>
            <div id="reliability-checks"></div>
          </div>

          <div class="visualization-section">
            <h4>Visual Analysis</h4>
            <div class="charts-grid">
              <div class="chart-container">
                <canvas id="confidenceIntervalChart"></canvas>
              </div>
              <div class="chart-container">
                <canvas id="comparisonChart"></canvas>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="footer">
        <p>Built with statistical rigor • Use for educational purposes</p>
      </div>
    </div>

    <script>
      let currentMetricType = "conversion";
      let currentAnalysisMethod = "frequentist";
      let confidenceIntervalChart = null;
      let comparisonChart = null;

      function switchAnalysisMethod(method) {
        currentAnalysisMethod = method;

        // Update tab appearances
        const tabs = document.querySelectorAll(".metric-selector")[0].querySelectorAll(".metric-tab");
        tabs.forEach((tab) => tab.classList.remove("active"));
        event.target.classList.add("active");

        // Show/hide descriptions
        document.getElementById("frequentist-description").style.display =
          method === "frequentist" ? "block" : "none";
        document.getElementById("bayesian-description").style.display =
          method === "bayesian" ? "block" : "none";

        // Hide results when switching
        document.getElementById("results").style.display = "none";
      }

      function switchMetricType(type) {
        currentMetricType = type;

        // Update tab appearances
        const tabs = document.querySelectorAll(".metric-selector")[1].querySelectorAll(".metric-tab");
        tabs.forEach((tab) => tab.classList.remove("active"));
        event.target.classList.add("active");

        // Show/hide input sections
        document
          .getElementById("conversion-inputs")
          .classList.toggle("active", type === "conversion");
        document
          .getElementById("continuous-inputs")
          .classList.toggle("active", type === "continuous");

        // Show/hide descriptions
        document.getElementById("conversion-description").style.display =
          type === "conversion" ? "block" : "none";
        document.getElementById("continuous-description").style.display =
          type === "continuous" ? "block" : "none";

        // Hide results when switching
        document.getElementById("results").style.display = "none";
      }

      function analyzeResults() {
        if (currentAnalysisMethod === "frequentist") {
          if (currentMetricType === "conversion") {
            analyzeConversionResults();
          } else {
            analyzeContinuousResults();
          }
        } else {
          // Bayesian analysis
          if (currentMetricType === "conversion") {
            analyzeBayesianConversion();
          } else {
            analyzeBayesianContinuous();
          }
        }
      }

      function analyzeConversionResults() {
        const controlVisitors = parseInt(
          document.getElementById("control-visitors").value
        );
        const controlConversions = parseInt(
          document.getElementById("control-conversions").value
        );
        const variantVisitors = parseInt(
          document.getElementById("variant-visitors").value
        );
        const variantConversions = parseInt(
          document.getElementById("variant-conversions").value
        );

        if (
          !controlVisitors ||
          !controlConversions ||
          !variantVisitors ||
          !variantConversions
        ) {
          alert("Please fill in all fields with valid numbers.");
          return;
        }

        if (
          controlConversions > controlVisitors ||
          variantConversions > variantVisitors
        ) {
          alert("Conversions cannot exceed visitors.");
          return;
        }

        const controlRate = controlConversions / controlVisitors;
        const variantRate = variantConversions / variantVisitors;
        const improvement = ((variantRate - controlRate) / controlRate) * 100;

        const pooledRate =
          (controlConversions + variantConversions) /
          (controlVisitors + variantVisitors);
        const standardError = Math.sqrt(
          pooledRate *
            (1 - pooledRate) *
            (1 / controlVisitors + 1 / variantVisitors)
        );
        const zScore = (variantRate - controlRate) / standardError;
        const pValue = 2 * (1 - normalCDF(Math.abs(zScore)));

        const controlSE = Math.sqrt(
          (controlRate * (1 - controlRate)) / controlVisitors
        );
        const variantSE = Math.sqrt(
          (variantRate * (1 - variantRate)) / variantVisitors
        );
        const diffSE = Math.sqrt(controlSE * controlSE + variantSE * variantSE);
        const marginOfError = 1.96 * diffSE;
        const lowerCI = variantRate - controlRate - marginOfError;
        const upperCI = variantRate - controlRate + marginOfError;

        const totalSample = controlVisitors + variantVisitors;
        const effectSize =
          Math.abs(variantRate - controlRate) /
          Math.sqrt(pooledRate * (1 - pooledRate));
        const statisticalPower = calculatePower(effectSize, totalSample);
        const mde = calculateMDE(totalSample, 0.8, 0.05);

        updateConversionResults(
          controlRate,
          variantRate,
          improvement,
          pValue,
          zScore,
          lowerCI,
          upperCI,
          totalSample,
          statisticalPower,
          mde
        );
        performConversionReliabilityChecks(
          controlVisitors,
          controlConversions,
          variantVisitors,
          variantConversions,
          pValue,
          statisticalPower
        );

        createConversionVisualizations(
          controlRate,
          variantRate,
          lowerCI,
          upperCI,
          controlVisitors,
          variantVisitors
        );

        document.getElementById("results").style.display = "block";
      }

      function analyzeContinuousResults() {
        const controlN = parseInt(
          document.getElementById("control-sample-size").value
        );
        const controlMean = parseFloat(
          document.getElementById("control-mean").value
        );
        const controlStd = parseFloat(
          document.getElementById("control-std").value
        );
        const variantN = parseInt(
          document.getElementById("variant-sample-size").value
        );
        const variantMean = parseFloat(
          document.getElementById("variant-mean").value
        );
        const variantStd = parseFloat(
          document.getElementById("variant-std").value
        );

        if (
          !controlN ||
          !controlMean ||
          !controlStd ||
          !variantN ||
          !variantMean ||
          !variantStd
        ) {
          alert("Please fill in all fields with valid numbers.");
          return;
        }

        if (controlStd <= 0 || variantStd <= 0) {
          alert("Standard deviation must be greater than 0.");
          return;
        }

        // Welch's t-test for unequal variances
        const meanDiff = variantMean - controlMean;
        const improvement = (meanDiff / controlMean) * 100;

        const se1 = (controlStd * controlStd) / controlN;
        const se2 = (variantStd * variantStd) / variantN;
        const pooledSE = Math.sqrt(se1 + se2);

        const tStatistic = meanDiff / pooledSE;

        // Welch-Satterthwaite equation for degrees of freedom
        const df =
          Math.pow(se1 + se2, 2) /
          (Math.pow(se1, 2) / (controlN - 1) +
            Math.pow(se2, 2) / (variantN - 1));

        const pValue = 2 * (1 - tCDF(Math.abs(tStatistic), df));

        // Confidence interval for mean difference
        const tCritical = tInverse(0.025, df); // 95% CI
        const marginOfError = tCritical * pooledSE;
        const lowerCI = meanDiff - marginOfError;
        const upperCI = meanDiff + marginOfError;

        // Cohen's d effect size
        const pooledStd = Math.sqrt(
          ((controlN - 1) * controlStd * controlStd +
            (variantN - 1) * variantStd * variantStd) /
            (controlN + variantN - 2)
        );
        const cohensD = meanDiff / pooledStd;

        const totalSample = controlN + variantN;
        const statisticalPower = calculateTTestPower(
          Math.abs(cohensD),
          controlN,
          variantN
        );
        const mde =
          calculateTTestMDE(controlN, variantN, 0.8, 0.05) * pooledStd;

        updateContinuousResults(
          controlMean,
          variantMean,
          improvement,
          pValue,
          tStatistic,
          df,
          lowerCI,
          upperCI,
          totalSample,
          statisticalPower,
          mde,
          cohensD
        );
        performContinuousReliabilityChecks(
          controlN,
          variantN,
          controlStd,
          variantStd,
          pValue,
          statisticalPower,
          cohensD
        );

        createContinuousVisualizations(
          controlMean,
          variantMean,
          controlStd,
          variantStd,
          lowerCI,
          upperCI,
          controlN,
          variantN
        );

        document.getElementById("results").style.display = "block";
      }

      // Bayesian Analysis Functions
      function analyzeBayesianConversion() {
        const controlVisitors = parseInt(
          document.getElementById("control-visitors").value
        );
        const controlConversions = parseInt(
          document.getElementById("control-conversions").value
        );
        const variantVisitors = parseInt(
          document.getElementById("variant-visitors").value
        );
        const variantConversions = parseInt(
          document.getElementById("variant-conversions").value
        );

        if (
          !controlVisitors ||
          !controlConversions ||
          !variantVisitors ||
          !variantConversions
        ) {
          alert("Please fill in all fields with valid numbers.");
          return;
        }

        if (
          controlConversions > controlVisitors ||
          variantConversions > variantVisitors
        ) {
          alert("Conversions cannot exceed visitors.");
          return;
        }

        const controlRate = controlConversions / controlVisitors;
        const variantRate = variantConversions / variantVisitors;
        const improvement = ((variantRate - controlRate) / controlRate) * 100;

        // Bayesian calculation using Beta distribution
        // Prior: Beta(1, 1) - uniform prior
        const alphaPrior = 1;
        const betaPrior = 1;

        // Posterior parameters
        const alphaControl = alphaPrior + controlConversions;
        const betaControl = betaPrior + (controlVisitors - controlConversions);
        const alphaVariant = alphaPrior + variantConversions;
        const betaVariant = betaPrior + (variantVisitors - variantConversions);

        // Monte Carlo simulation to calculate probability B > A
        const numSamples = 100000;
        let countBWins = 0;
        let sumLossChooseA = 0;
        let sumLossChooseB = 0;

        for (let i = 0; i < numSamples; i++) {
          const sampleA = betaRandom(alphaControl, betaControl);
          const sampleB = betaRandom(alphaVariant, betaVariant);

          if (sampleB > sampleA) {
            countBWins++;
            sumLossChooseA += sampleB - sampleA;
          } else {
            sumLossChooseB += sampleA - sampleB;
          }
        }

        const probBWins = countBWins / numSamples;
        const expectedLossA = sumLossChooseA / numSamples; // Loss if we choose A but B is better
        const expectedLossB = sumLossChooseB / numSamples; // Loss if we choose B but A is better

        // Credible intervals (95%)
        const credibleIntervalControl = betaCredibleInterval(alphaControl, betaControl, 0.95);
        const credibleIntervalVariant = betaCredibleInterval(alphaVariant, betaVariant, 0.95);

        // Calculate credible interval for the difference
        const diffSamples = [];
        for (let i = 0; i < 10000; i++) {
          const sampleA = betaRandom(alphaControl, betaControl);
          const sampleB = betaRandom(alphaVariant, betaVariant);
          diffSamples.push((sampleB - sampleA) * 100);
        }
        diffSamples.sort((a, b) => a - b);
        const lowerCIDiff = diffSamples[Math.floor(diffSamples.length * 0.025)];
        const upperCIDiff = diffSamples[Math.floor(diffSamples.length * 0.975)];

        const totalSample = controlVisitors + variantVisitors;

        updateBayesianConversionResults(
          controlRate,
          variantRate,
          improvement,
          probBWins,
          expectedLossA,
          expectedLossB,
          credibleIntervalControl,
          credibleIntervalVariant,
          lowerCIDiff,
          upperCIDiff,
          totalSample
        );

        createBayesianConversionVisualizations(
          alphaControl,
          betaControl,
          alphaVariant,
          betaVariant,
          controlRate,
          variantRate,
          probBWins
        );

        performBayesianConversionReliabilityChecks(
          controlVisitors,
          controlConversions,
          variantVisitors,
          variantConversions,
          probBWins,
          expectedLossA,
          expectedLossB
        );

        document.getElementById("results").style.display = "block";
      }

      function analyzeBayesianContinuous() {
        const controlN = parseInt(
          document.getElementById("control-sample-size").value
        );
        const controlMean = parseFloat(
          document.getElementById("control-mean").value
        );
        const controlStd = parseFloat(
          document.getElementById("control-std").value
        );
        const variantN = parseInt(
          document.getElementById("variant-sample-size").value
        );
        const variantMean = parseFloat(
          document.getElementById("variant-mean").value
        );
        const variantStd = parseFloat(
          document.getElementById("variant-std").value
        );

        if (
          !controlN ||
          !controlMean ||
          !controlStd ||
          !variantN ||
          !variantMean ||
          !variantStd
        ) {
          alert("Please fill in all fields with valid numbers.");
          return;
        }

        if (controlStd <= 0 || variantStd <= 0) {
          alert("Standard deviation must be greater than 0.");
          return;
        }

        const improvement = ((variantMean - controlMean) / controlMean) * 100;

        // Monte Carlo simulation using normal distributions
        const numSamples = 100000;
        let countBWins = 0;
        let sumLossChooseA = 0;
        let sumLossChooseB = 0;
        const diffSamples = [];

        for (let i = 0; i < numSamples; i++) {
          const sampleA = normalRandom(controlMean, controlStd / Math.sqrt(controlN));
          const sampleB = normalRandom(variantMean, variantStd / Math.sqrt(variantN));

          if (sampleB > sampleA) {
            countBWins++;
            sumLossChooseA += sampleB - sampleA;
          } else {
            sumLossChooseB += sampleA - sampleB;
          }

          if (i < 10000) {
            diffSamples.push(sampleB - sampleA);
          }
        }

        const probBWins = countBWins / numSamples;
        const expectedLossA = sumLossChooseA / numSamples;
        const expectedLossB = sumLossChooseB / numSamples;

        // Credible intervals
        diffSamples.sort((a, b) => a - b);
        const lowerCIDiff = diffSamples[Math.floor(diffSamples.length * 0.025)];
        const upperCIDiff = diffSamples[Math.floor(diffSamples.length * 0.975)];

        const totalSample = controlN + variantN;

        updateBayesianContinuousResults(
          controlMean,
          variantMean,
          improvement,
          probBWins,
          expectedLossA,
          expectedLossB,
          lowerCIDiff,
          upperCIDiff,
          totalSample
        );

        createBayesianContinuousVisualizations(
          controlMean,
          controlStd,
          controlN,
          variantMean,
          variantStd,
          variantN,
          probBWins
        );

        performBayesianContinuousReliabilityChecks(
          controlN,
          variantN,
          probBWins,
          expectedLossA,
          expectedLossB
        );

        document.getElementById("results").style.display = "block";
      }

      // Helper function: Generate Beta random variable
      function betaRandom(alpha, beta) {
        const gamma1 = gammaRandom(alpha);
        const gamma2 = gammaRandom(beta);
        return gamma1 / (gamma1 + gamma2);
      }

      // Helper function: Generate Gamma random variable (using Marsaglia and Tsang method)
      function gammaRandom(shape) {
        if (shape < 1) {
          return gammaRandom(shape + 1) * Math.pow(Math.random(), 1 / shape);
        }

        const d = shape - 1 / 3;
        const c = 1 / Math.sqrt(9 * d);

        while (true) {
          let x, v;
          do {
            x = normalRandom(0, 1);
            v = 1 + c * x;
          } while (v <= 0);

          v = v * v * v;
          const u = Math.random();
          const x2 = x * x;

          if (u < 1 - 0.0331 * x2 * x2) {
            return d * v;
          }

          if (Math.log(u) < 0.5 * x2 + d * (1 - v + Math.log(v))) {
            return d * v;
          }
        }
      }

      // Helper function: Generate normal random variable (Box-Muller transform)
      function normalRandom(mean, stddev) {
        const u1 = Math.random();
        const u2 = Math.random();
        const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        return mean + stddev * z0;
      }

      // Helper function: Calculate Beta credible interval
      function betaCredibleInterval(alpha, beta, confidence) {
        const lowerP = (1 - confidence) / 2;
        const upperP = 1 - lowerP;

        // Approximate using quantile function
        const lower = betaQuantile(lowerP, alpha, beta);
        const upper = betaQuantile(upperP, alpha, beta);

        return [lower, upper];
      }

      // Approximate beta quantile using bisection
      function betaQuantile(p, alpha, beta) {
        let low = 0, high = 1;
        const tolerance = 0.0001;

        for (let i = 0; i < 100; i++) {
          const mid = (low + high) / 2;
          const cdf = incompleteBeta(mid, alpha, beta);

          if (Math.abs(cdf - p) < tolerance) {
            return mid;
          }

          if (cdf < p) {
            low = mid;
          } else {
            high = mid;
          }
        }

        return (low + high) / 2;
      }

      // Incomplete beta function (approximation)
      function incompleteBeta(x, a, b) {
        if (x === 0) return 0;
        if (x === 1) return 1;

        // Use continued fraction approximation
        const bt = Math.exp(
          a * Math.log(x) + b * Math.log(1 - x) -
          logBeta(a, b)
        );

        if (x < (a + 1) / (a + b + 2)) {
          return bt * betaContinuedFraction(x, a, b) / a;
        } else {
          return 1 - bt * betaContinuedFraction(1 - x, b, a) / b;
        }
      }

      function betaContinuedFraction(x, a, b) {
        const maxIter = 100;
        const epsilon = 1e-10;

        let am = 1;
        let bm = 1;
        let az = 1;

        const qab = a + b;
        const qap = a + 1;
        const qam = a - 1;
        let bz = 1 - qab * x / qap;

        for (let m = 1; m <= maxIter; m++) {
          const em = m;
          const tem = em + em;
          let d = em * (b - m) * x / ((qam + tem) * (a + tem));

          let ap = az + d * am;
          let bp = bz + d * bm;

          d = -(a + em) * (qab + em) * x / ((a + tem) * (qap + tem));
          const app = ap + d * az;
          const bpp = bp + d * bz;

          const aold = az;
          am = ap / bpp;
          bm = bp / bpp;
          az = app / bpp;
          bz = 1;

          if (Math.abs(az - aold) < epsilon * Math.abs(az)) {
            return az;
          }
        }

        return az;
      }

      function logBeta(a, b) {
        return logGamma(a) + logGamma(b) - logGamma(a + b);
      }

      function logGamma(x) {
        const cof = [
          76.18009172947146, -86.50532032941677,
          24.01409824083091, -1.231739572450155,
          0.1208650973866179e-2, -0.5395239384953e-5
        ];

        let y = x;
        let tmp = x + 5.5;
        tmp -= (x + 0.5) * Math.log(tmp);
        let ser = 1.000000000190015;

        for (let j = 0; j < 6; j++) {
          ser += cof[j] / ++y;
        }

        return -tmp + Math.log(2.5066282746310005 * ser / x);
      }

      function normalCDF(x) {
        return 0.5 * (1 + erf(x / Math.sqrt(2)));
      }

      function erf(x) {
        const a1 = 0.254829592;
        const a2 = -0.284496736;
        const a3 = 1.421413741;
        const a4 = -1.453152027;
        const a5 = 1.061405429;
        const p = 0.3275911;

        const sign = x < 0 ? -1 : 1;
        x = Math.abs(x);

        const t = 1.0 / (1.0 + p * x);
        const y =
          1.0 -
          ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);

        return sign * y;
      }

      function calculatePower(effectSize, sampleSize) {
        const alpha = 0.05;
        const criticalValue = 1.96;
        const beta = normalCDF(
          criticalValue - effectSize * Math.sqrt(sampleSize / 2)
        );
        return Math.max(0, Math.min(1, 1 - beta));
      }

      function calculateMDE(sampleSize, power, alpha) {
        const criticalValue = 1.96;
        const powerValue = 0.84;
        return (criticalValue + powerValue) / Math.sqrt(sampleSize / 2);
      }

      // T-distribution functions
      function tCDF(t, df) {
        // Approximation for t-distribution CDF
        if (df >= 30) {
          return normalCDF(t);
        }

        // Use gamma function approximation for smaller df
        const x = t / Math.sqrt(df);
        const a = 0.5;
        const b = df / 2;

        // Simple approximation - for production use, implement proper incomplete beta function
        const p =
          0.5 +
          0.5 *
            Math.sign(t) *
            (1 - Math.exp(-0.717 * Math.abs(t) - 0.416 * t * t));
        return Math.max(0, Math.min(1, p));
      }

      function tInverse(p, df) {
        // Approximation for t-distribution inverse CDF
        if (df >= 30) {
          return normalInverse(p);
        }

        // Simple approximation for t-inverse
        const z = normalInverse(p);
        const correction = (z * z * z + z) / (4 * df);
        return z + correction;
      }

      function normalInverse(p) {
        // Approximation for standard normal inverse CDF
        if (p <= 0 || p >= 1) return p <= 0 ? -Infinity : Infinity;

        const c0 = 2.515517;
        const c1 = 0.802853;
        const c2 = 0.010328;
        const d1 = 1.432788;
        const d2 = 0.189269;
        const d3 = 0.001308;

        let x, t;
        if (p > 0.5) {
          t = Math.sqrt(-2 * Math.log(1 - p));
          x =
            t -
            (c0 + c1 * t + c2 * t * t) /
              (1 + d1 * t + d2 * t * t + d3 * t * t * t);
        } else {
          t = Math.sqrt(-2 * Math.log(p));
          x = -(
            t -
            (c0 + c1 * t + c2 * t * t) /
              (1 + d1 * t + d2 * t * t + d3 * t * t * t)
          );
        }

        return x;
      }

      function calculateTTestPower(effectSize, n1, n2) {
        // Approximate power calculation for t-test
        const df = n1 + n2 - 2;
        const ncp = effectSize * Math.sqrt((n1 * n2) / (n1 + n2));
        const criticalT = tInverse(0.975, df);

        // Non-central t approximation
        const power =
          1 - tCDF(criticalT - ncp, df) + tCDF(-criticalT - ncp, df);
        return Math.max(0, Math.min(1, power));
      }

      function calculateTTestMDE(n1, n2, power, alpha) {
        // Approximate MDE calculation for t-test
        const df = n1 + n2 - 2;
        const criticalT = tInverse(1 - alpha / 2, df);
        const powerT = tInverse(power, df);

        return (criticalT + powerT) / Math.sqrt((n1 * n2) / (n1 + n2));
      }

      function updateConversionResults(
        controlRate,
        variantRate,
        improvement,
        pValue,
        zScore,
        lowerCI,
        upperCI,
        totalSample,
        statisticalPower,
        mde
      ) {
        // Update UI labels for conversion analysis
        document.getElementById("primary-metric-title").textContent =
          "Conversion Rates";
        document.getElementById("control-label").textContent = "Control (A):";
        document.getElementById("variant-label").textContent = "Variant (B):";
        document.getElementById("test-statistic-label").textContent =
          "Z-score:";
        document.getElementById("effect-size-metric").style.display = "none";
        document.getElementById("degrees-freedom").style.display = "none";

        document.getElementById("control-rate").textContent =
          (controlRate * 100).toFixed(2) + "%";
        document.getElementById("variant-rate").textContent =
          (variantRate * 100).toFixed(2) + "%";
        document.getElementById("improvement").textContent =
          (improvement >= 0 ? "+" : "") + improvement.toFixed(2) + "%";
        document.getElementById("p-value").textContent = pValue.toFixed(4);
        document.getElementById("z-score").textContent = zScore.toFixed(3);
        document.getElementById("confidence-interval").textContent = `[${(
          lowerCI * 100
        ).toFixed(2)}%, ${(upperCI * 100).toFixed(2)}%]`;
        document.getElementById("total-sample").textContent =
          totalSample.toLocaleString();
        document.getElementById("statistical-power").textContent =
          (statisticalPower * 100).toFixed(1) + "%";
        document.getElementById("mde").textContent =
          (mde * 100).toFixed(2) + "%";

        updateSignificanceBadge(pValue);
      }

      function updateContinuousResults(
        controlMean,
        variantMean,
        improvement,
        pValue,
        tStatistic,
        df,
        lowerCI,
        upperCI,
        totalSample,
        statisticalPower,
        mde,
        cohensD
      ) {
        // Update UI labels for continuous analysis
        document.getElementById("primary-metric-title").textContent =
          "Mean Values";
        document.getElementById("control-label").textContent = "Control Mean:";
        document.getElementById("variant-label").textContent = "Variant Mean:";
        document.getElementById("test-statistic-label").textContent =
          "T-statistic:";
        document.getElementById("effect-size-metric").style.display = "block";
        document.getElementById("degrees-freedom").style.display = "block";

        document.getElementById("control-rate").textContent =
          controlMean.toFixed(2);
        document.getElementById("variant-rate").textContent =
          variantMean.toFixed(2);
        document.getElementById("improvement").textContent =
          (improvement >= 0 ? "+" : "") + improvement.toFixed(2) + "%";
        document.getElementById("p-value").textContent = pValue.toFixed(4);
        document.getElementById("z-score").textContent = tStatistic.toFixed(3);
        document.getElementById("df").textContent = df.toFixed(1);
        document.getElementById(
          "confidence-interval"
        ).textContent = `[${lowerCI.toFixed(2)}, ${upperCI.toFixed(2)}]`;
        document.getElementById("total-sample").textContent =
          totalSample.toLocaleString();
        document.getElementById("statistical-power").textContent =
          (statisticalPower * 100).toFixed(1) + "%";
        document.getElementById("mde").textContent = mde.toFixed(2);
        document.getElementById("effect-size").textContent = cohensD.toFixed(3);

        updateSignificanceBadge(pValue);
      }

      function updateSignificanceBadge(pValue) {
        const significanceBadge = document.getElementById("significance-badge");
        if (pValue < 0.05) {
          significanceBadge.innerHTML =
            '<span class="significance-badge significant">Statistically Significant</span>';
        } else {
          significanceBadge.innerHTML =
            '<span class="significance-badge not-significant">Not Statistically Significant</span>';
        }
      }

      // Bayesian Results Update Functions
      function updateBayesianConversionResults(
        controlRate,
        variantRate,
        improvement,
        probBWins,
        expectedLossA,
        expectedLossB,
        credibleIntervalControl,
        credibleIntervalVariant,
        lowerCIDiff,
        upperCIDiff,
        totalSample
      ) {
        document.getElementById("primary-metric-title").textContent =
          "Conversion Rates";
        document.getElementById("control-label").textContent = "Control (A):";
        document.getElementById("variant-label").textContent = "Variant (B):";
        document.getElementById("test-statistic-label").textContent =
          "Prob(B > A):";
        document.getElementById("effect-size-metric").style.display = "none";
        document.getElementById("degrees-freedom").style.display = "none";

        document.getElementById("control-rate").textContent =
          (controlRate * 100).toFixed(2) + "%";
        document.getElementById("variant-rate").textContent =
          (variantRate * 100).toFixed(2) + "%";
        document.getElementById("improvement").textContent =
          (improvement >= 0 ? "+" : "") + improvement.toFixed(2) + "%";
        document.getElementById("z-score").textContent = (probBWins * 100).toFixed(1) + "%";
        document.getElementById("p-value").textContent =
          expectedLossB < expectedLossA
            ? (expectedLossB * 100).toFixed(3) + "%"
            : (expectedLossA * 100).toFixed(3) + "%";
        document.getElementById("confidence-interval").textContent = `[${
          lowerCIDiff.toFixed(2)
        }%, ${upperCIDiff.toFixed(2)}%]`;
        document.getElementById("total-sample").textContent =
          totalSample.toLocaleString();
        document.getElementById("statistical-power").textContent =
          probBWins >= 0.95 ? "High" : probBWins >= 0.80 ? "Medium" : "Low";
        document.getElementById("mde").textContent =
          expectedLossB < expectedLossA
            ? (expectedLossB * 100).toFixed(3) + "%"
            : (expectedLossA * 100).toFixed(3) + "%";

        // Update label text for Bayesian
        document.querySelector('[id="p-value"]').parentElement.querySelector('.metric-label').textContent = "Expected Loss:";
        document.querySelector('[id="statistical-power"]').parentElement.querySelector('.metric-label').textContent = "Decision Confidence:";
        document.querySelector('[id="mde"]').parentElement.querySelector('.metric-label').textContent = "Risk of Wrong Choice:";

        updateBayesianBadge(probBWins);
      }

      function updateBayesianContinuousResults(
        controlMean,
        variantMean,
        improvement,
        probBWins,
        expectedLossA,
        expectedLossB,
        lowerCIDiff,
        upperCIDiff,
        totalSample
      ) {
        document.getElementById("primary-metric-title").textContent =
          "Mean Values";
        document.getElementById("control-label").textContent = "Control Mean:";
        document.getElementById("variant-label").textContent = "Variant Mean:";
        document.getElementById("test-statistic-label").textContent =
          "Prob(B > A):";
        document.getElementById("effect-size-metric").style.display = "none";
        document.getElementById("degrees-freedom").style.display = "none";

        document.getElementById("control-rate").textContent =
          controlMean.toFixed(2);
        document.getElementById("variant-rate").textContent =
          variantMean.toFixed(2);
        document.getElementById("improvement").textContent =
          (improvement >= 0 ? "+" : "") + improvement.toFixed(2) + "%";
        document.getElementById("z-score").textContent = (probBWins * 100).toFixed(1) + "%";
        document.getElementById("p-value").textContent =
          expectedLossB < expectedLossA
            ? expectedLossB.toFixed(3)
            : expectedLossA.toFixed(3);
        document.getElementById("confidence-interval").textContent = `[${lowerCIDiff.toFixed(
          2
        )}, ${upperCIDiff.toFixed(2)}]`;
        document.getElementById("total-sample").textContent =
          totalSample.toLocaleString();
        document.getElementById("statistical-power").textContent =
          probBWins >= 0.95 ? "High" : probBWins >= 0.80 ? "Medium" : "Low";
        document.getElementById("mde").textContent =
          expectedLossB < expectedLossA
            ? expectedLossB.toFixed(3)
            : expectedLossA.toFixed(3);

        // Update label text for Bayesian
        document.querySelector('[id="p-value"]').parentElement.querySelector('.metric-label').textContent = "Expected Loss:";
        document.querySelector('[id="statistical-power"]').parentElement.querySelector('.metric-label').textContent = "Decision Confidence:";
        document.querySelector('[id="mde"]').parentElement.querySelector('.metric-label').textContent = "Risk of Wrong Choice:";

        updateBayesianBadge(probBWins);
      }

      function updateBayesianBadge(probBWins) {
        const significanceBadge = document.getElementById("significance-badge");
        if (probBWins >= 0.95) {
          significanceBadge.innerHTML =
            '<span class="significance-badge significant">Strong Evidence (>95%)</span>';
        } else if (probBWins >= 0.80) {
          significanceBadge.innerHTML =
            '<span class="significance-badge warning">Moderate Evidence (80-95%)</span>';
        } else {
          significanceBadge.innerHTML =
            '<span class="significance-badge not-significant">Weak Evidence (<80%)</span>';
        }
      }

      function performConversionReliabilityChecks(
        controlVisitors,
        controlConversions,
        variantVisitors,
        variantConversions,
        pValue,
        statisticalPower
      ) {
        const checks = [];
        const minSampleSize = 100;
        const minConversions = 10;
        const minPower = 0.8;

        if (
          controlVisitors >= minSampleSize &&
          variantVisitors >= minSampleSize
        ) {
          checks.push({
            status: "check",
            message: "Sample sizes are adequate (≥100 per variant)",
          });
        } else {
          checks.push({
            status: "error",
            message:
              "Sample sizes too small (<100 per variant) - results may be unreliable",
          });
        }

        if (
          controlConversions >= minConversions &&
          variantConversions >= minConversions
        ) {
          checks.push({
            status: "check",
            message: "Sufficient conversions observed (≥10 per variant)",
          });
        } else {
          checks.push({
            status: "warning",
            message:
              "Low conversion counts (<10 per variant) - consider running test longer",
          });
        }

        if (statisticalPower >= minPower) {
          checks.push({
            status: "check",
            message: `High statistical power (${(
              statisticalPower * 100
            ).toFixed(1)}% ≥ 80%)`,
          });
        } else {
          checks.push({
            status: "warning",
            message: `Low statistical power (${(statisticalPower * 100).toFixed(
              1
            )}% < 80%) - may miss true effects`,
          });
        }

        const sampleRatio =
          Math.min(controlVisitors, variantVisitors) /
          Math.max(controlVisitors, variantVisitors);
        if (sampleRatio >= 0.8) {
          checks.push({
            status: "check",
            message: "Sample sizes are well-balanced between variants",
          });
        } else {
          checks.push({
            status: "warning",
            message: "Unbalanced sample sizes - consider equal allocation",
          });
        }

        if (pValue < 0.05 && statisticalPower >= 0.8) {
          checks.push({
            status: "check",
            message: "Results are both significant and well-powered",
          });
        } else if (pValue >= 0.05 && statisticalPower < 0.8) {
          checks.push({
            status: "warning",
            message:
              "Non-significant result with low power - inconclusive test",
          });
        }

        const checksHTML = checks
          .map(
            (check) => `
                <div class="reliability-item">
                    <span class="reliability-icon ${
                      check.status === "check"
                        ? "check"
                        : check.status === "warning"
                        ? "warning-icon"
                        : "error-icon"
                    }"></span>
                    <span>${check.message}</span>
                </div>
            `
          )
          .join("");

        document.getElementById("reliability-checks").innerHTML = checksHTML;
      }

      function performBayesianConversionReliabilityChecks(
        controlVisitors,
        controlConversions,
        variantVisitors,
        variantConversions,
        probBWins,
        expectedLossA,
        expectedLossB
      ) {
        const checks = [];
        const minSampleSize = 50;
        const minConversions = 5;

        if (
          controlVisitors >= minSampleSize &&
          variantVisitors >= minSampleSize
        ) {
          checks.push({
            status: "check",
            message: "Sample sizes are adequate (≥50 per variant)",
          });
        } else {
          checks.push({
            status: "warning",
            message:
              "Small sample sizes (<50 per variant) - posteriors may have high uncertainty",
          });
        }

        if (
          controlConversions >= minConversions &&
          variantConversions >= minConversions
        ) {
          checks.push({
            status: "check",
            message: "Sufficient conversions observed (≥5 per variant)",
          });
        } else {
          checks.push({
            status: "warning",
            message:
              "Low conversion counts (<5 per variant) - posteriors heavily influenced by prior",
          });
        }

        const sampleRatio =
          Math.min(controlVisitors, variantVisitors) /
          Math.max(controlVisitors, variantVisitors);
        if (sampleRatio >= 0.8) {
          checks.push({
            status: "check",
            message: "Sample sizes are well-balanced between variants",
          });
        } else {
          checks.push({
            status: "warning",
            message: "Unbalanced sample sizes - consider equal allocation",
          });
        }

        if (probBWins >= 0.95 || probBWins <= 0.05) {
          checks.push({
            status: "check",
            message: `Strong evidence (${(Math.max(probBWins, 1-probBWins) * 100).toFixed(1)}% probability)`,
          });
        } else if (probBWins >= 0.80 || probBWins <= 0.20) {
          checks.push({
            status: "warning",
            message: `Moderate evidence (${(Math.max(probBWins, 1-probBWins) * 100).toFixed(1)}% probability) - consider collecting more data`,
          });
        } else {
          checks.push({
            status: "warning",
            message: "Weak evidence - insufficient data to make a confident decision",
          });
        }

        const minLoss = Math.min(expectedLossA, expectedLossB);
        if (minLoss < 0.001) {
          checks.push({
            status: "check",
            message: `Very low risk of wrong decision (${(minLoss * 100).toFixed(3)}% expected loss)`,
          });
        } else if (minLoss < 0.01) {
          checks.push({
            status: "check",
            message: `Low risk of wrong decision (${(minLoss * 100).toFixed(2)}% expected loss)`,
          });
        } else {
          checks.push({
            status: "warning",
            message: `Moderate risk of wrong decision (${(minLoss * 100).toFixed(2)}% expected loss)`,
          });
        }

        const checksHTML = checks
          .map(
            (check) => `
                <div class="reliability-item">
                    <span class="reliability-icon ${
                      check.status === "check"
                        ? "check"
                        : check.status === "warning"
                        ? "warning-icon"
                        : "error-icon"
                    }"></span>
                    <span>${check.message}</span>
                </div>
            `
          )
          .join("");

        document.getElementById("reliability-checks").innerHTML = checksHTML;
      }

      function performBayesianContinuousReliabilityChecks(
        controlN,
        variantN,
        probBWins,
        expectedLossA,
        expectedLossB
      ) {
        const checks = [];
        const minSampleSize = 20;

        if (controlN >= minSampleSize && variantN >= minSampleSize) {
          checks.push({
            status: "check",
            message: "Sample sizes are adequate (≥20 per variant)",
          });
        } else {
          checks.push({
            status: "warning",
            message:
              "Small sample sizes (<20 per variant) - posteriors may have high uncertainty",
          });
        }

        const sampleRatio =
          Math.min(controlN, variantN) / Math.max(controlN, variantN);
        if (sampleRatio >= 0.8) {
          checks.push({
            status: "check",
            message: "Sample sizes are well-balanced between variants",
          });
        } else {
          checks.push({
            status: "warning",
            message: "Unbalanced sample sizes - consider equal allocation",
          });
        }

        if (probBWins >= 0.95 || probBWins <= 0.05) {
          checks.push({
            status: "check",
            message: `Strong evidence (${(Math.max(probBWins, 1-probBWins) * 100).toFixed(1)}% probability)`,
          });
        } else if (probBWins >= 0.80 || probBWins <= 0.20) {
          checks.push({
            status: "warning",
            message: `Moderate evidence (${(Math.max(probBWins, 1-probBWins) * 100).toFixed(1)}% probability) - consider collecting more data`,
          });
        } else {
          checks.push({
            status: "warning",
            message: "Weak evidence - insufficient data to make a confident decision",
          });
        }

        const minLoss = Math.min(expectedLossA, expectedLossB);
        if (minLoss < 0.5) {
          checks.push({
            status: "check",
            message: `Very low risk of wrong decision (${minLoss.toFixed(2)} expected loss)`,
          });
        } else if (minLoss < 2) {
          checks.push({
            status: "check",
            message: `Low risk of wrong decision (${minLoss.toFixed(2)} expected loss)`,
          });
        } else {
          checks.push({
            status: "warning",
            message: `Moderate risk of wrong decision (${minLoss.toFixed(2)} expected loss)`,
          });
        }

        const checksHTML = checks
          .map(
            (check) => `
                <div class="reliability-item">
                    <span class="reliability-icon ${
                      check.status === "check"
                        ? "check"
                        : check.status === "warning"
                        ? "warning-icon"
                        : "error-icon"
                    }"></span>
                    <span>${check.message}</span>
                </div>
            `
          )
          .join("");

        document.getElementById("reliability-checks").innerHTML = checksHTML;
      }

      function performContinuousReliabilityChecks(
        controlN,
        variantN,
        controlStd,
        variantStd,
        pValue,
        statisticalPower,
        cohensD
      ) {
        const checks = [];
        const minSampleSize = 30;
        const minPower = 0.8;

        if (controlN >= minSampleSize && variantN >= minSampleSize) {
          checks.push({
            status: "check",
            message: "Sample sizes are adequate (≥30 per variant for t-test)",
          });
        } else {
          checks.push({
            status: "error",
            message:
              "Sample sizes too small (<30 per variant) - t-test assumptions may be violated",
          });
        }

        // Check for equal variances assumption
        const varianceRatio =
          Math.max(controlStd, variantStd) / Math.min(controlStd, variantStd);
        if (varianceRatio <= 2) {
          checks.push({
            status: "check",
            message:
              "Variances appear similar (ratio ≤ 2) - Welch's t-test is appropriate",
          });
        } else {
          checks.push({
            status: "warning",
            message: `Large variance difference (ratio: ${varianceRatio.toFixed(
              2
            )}) - consider non-parametric tests`,
          });
        }

        if (statisticalPower >= minPower) {
          checks.push({
            status: "check",
            message: `High statistical power (${(
              statisticalPower * 100
            ).toFixed(1)}% ≥ 80%)`,
          });
        } else {
          checks.push({
            status: "warning",
            message: `Low statistical power (${(statisticalPower * 100).toFixed(
              1
            )}% < 80%) - may miss true effects`,
          });
        }

        const sampleRatio =
          Math.min(controlN, variantN) / Math.max(controlN, variantN);
        if (sampleRatio >= 0.8) {
          checks.push({
            status: "check",
            message: "Sample sizes are well-balanced between variants",
          });
        } else {
          checks.push({
            status: "warning",
            message: "Unbalanced sample sizes - consider equal allocation",
          });
        }

        // Effect size interpretation
        const absCohensD = Math.abs(cohensD);
        if (absCohensD >= 0.8) {
          checks.push({
            status: "check",
            message: `Large effect size (|d| = ${absCohensD.toFixed(
              3
            )} ≥ 0.8) - practically significant`,
          });
        } else if (absCohensD >= 0.5) {
          checks.push({
            status: "check",
            message: `Medium effect size (|d| = ${absCohensD.toFixed(
              3
            )}) - moderate practical significance`,
          });
        } else if (absCohensD >= 0.2) {
          checks.push({
            status: "warning",
            message: `Small effect size (|d| = ${absCohensD.toFixed(
              3
            )}) - limited practical significance`,
          });
        } else {
          checks.push({
            status: "warning",
            message: `Very small effect size (|d| = ${absCohensD.toFixed(
              3
            )}) - questionable practical significance`,
          });
        }

        if (pValue < 0.05 && statisticalPower >= 0.8) {
          checks.push({
            status: "check",
            message: "Results are both significant and well-powered",
          });
        } else if (pValue >= 0.05 && statisticalPower < 0.8) {
          checks.push({
            status: "warning",
            message:
              "Non-significant result with low power - inconclusive test",
          });
        }

        const checksHTML = checks
          .map(
            (check) => `
                <div class="reliability-item">
                    <span class="reliability-icon ${
                      check.status === "check"
                        ? "check"
                        : check.status === "warning"
                        ? "warning-icon"
                        : "error-icon"
                    }"></span>
                    <span>${check.message}</span>
                </div>
            `
          )
          .join("");

        document.getElementById("reliability-checks").innerHTML = checksHTML;
      }

      function createConversionVisualizations(
        controlRate,
        variantRate,
        lowerCI,
        upperCI,
        controlN,
        variantN
      ) {
        // Destroy existing charts
        if (confidenceIntervalChart) confidenceIntervalChart.destroy();
        if (comparisonChart) comparisonChart.destroy();

        // Calculate standard errors for error bars on individual rates
        const controlSE = Math.sqrt((controlRate * (1 - controlRate)) / controlN);
        const variantSE = Math.sqrt((variantRate * (1 - variantRate)) / variantN);

        // 1. Confidence Interval Chart - Forest Plot Style
        const ctx1 = document
          .getElementById("confidenceIntervalChart")
          .getContext("2d");
        const diff = variantRate - controlRate;
        const diffPercent = diff * 100;
        const lowerCIPercent = lowerCI * 100;
        const upperCIPercent = upperCI * 100;

        confidenceIntervalChart = new Chart(ctx1, {
          type: "scatter",
          data: {
            datasets: [
              {
                label: "Lift with 95% CI",
                data: [{ x: diffPercent, y: 0.5 }],
                backgroundColor: diffPercent > 0 ? "rgba(56, 161, 105, 0.8)" : "rgba(229, 62, 62, 0.8)",
                borderColor: diffPercent > 0 ? "rgba(56, 161, 105, 1)" : "rgba(229, 62, 62, 1)",
                borderWidth: 2,
                pointRadius: 8,
                pointStyle: "circle",
              },
              {
                label: "Confidence Interval",
                data: [
                  { x: lowerCIPercent, y: 0.5 },
                  { x: upperCIPercent, y: 0.5 }
                ],
                showLine: true,
                borderColor: "rgba(102, 126, 234, 0.8)",
                borderWidth: 3,
                pointRadius: 0,
                fill: false,
              },
              {
                label: "No Effect Line",
                data: [
                  { x: 0, y: 0 },
                  { x: 0, y: 1 }
                ],
                showLine: true,
                borderColor: "rgba(0, 0, 0, 0.3)",
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: true,
                text: "Lift in Conversion Rate with 95% Confidence Interval",
                font: { size: 14, weight: "600" },
              },
              legend: {
                display: true,
                position: "bottom",
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    if (context.datasetIndex === 0) {
                      return `Lift: ${diffPercent.toFixed(2)}% [${lowerCIPercent.toFixed(2)}%, ${upperCIPercent.toFixed(2)}%]`;
                    }
                    return '';
                  }
                }
              }
            },
            scales: {
              x: {
                title: {
                  display: true,
                  text: "Difference in Conversion Rate (%)",
                },
                ticks: {
                  callback: function (value) {
                    return value.toFixed(1) + "%";
                  },
                },
              },
              y: {
                display: false,
                min: 0,
                max: 1,
              },
            },
          },
        });

        // 2. Comparison Bar Chart
        const ctx2 = document
          .getElementById("comparisonChart")
          .getContext("2d");
        comparisonChart = new Chart(ctx2, {
          type: "bar",
          data: {
            labels: ["Control (A)", "Variant (B)"],
            datasets: [
              {
                label: "Conversion Rate",
                data: [controlRate * 100, variantRate * 100],
                backgroundColor: [
                  "rgba(229, 62, 62, 0.7)",
                  "rgba(56, 161, 105, 0.7)",
                ],
                borderColor: ["rgba(229, 62, 62, 1)", "rgba(56, 161, 105, 1)"],
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: true,
                text: "Conversion Rate Comparison",
                font: { size: 14, weight: "600" },
              },
              legend: {
                display: false,
              },
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: "Conversion Rate (%)",
                },
                ticks: {
                  callback: function (value) {
                    return value.toFixed(1) + "%";
                  },
                },
              },
            },
          },
        });
      }

      // Bayesian Visualization Functions
      function createBayesianConversionVisualizations(
        alphaControl,
        betaControl,
        alphaVariant,
        betaVariant,
        controlRate,
        variantRate,
        probBWins
      ) {
        // Destroy existing charts
        if (confidenceIntervalChart) confidenceIntervalChart.destroy();
        if (comparisonChart) comparisonChart.destroy();

        // 1. Posterior Distribution Chart
        const ctx1 = document
          .getElementById("confidenceIntervalChart")
          .getContext("2d");

        // Generate beta distribution curves
        // Focus on a reasonable range around the observed rates
        const minRate = Math.max(0.001, Math.min(controlRate, variantRate) - 0.1);
        const maxRate = Math.min(0.999, Math.max(controlRate, variantRate) + 0.1);

        const points = 200;
        const xValues = [];
        const controlDist = [];
        const variantDist = [];

        for (let i = 0; i <= points; i++) {
          const x = minRate + (i / points) * (maxRate - minRate);
          xValues.push((x * 100).toFixed(2));

          const controlPDF = betaPDF(x, alphaControl, betaControl);
          const variantPDF = betaPDF(x, alphaVariant, betaVariant);

          controlDist.push(controlPDF);
          variantDist.push(variantPDF);
        }

        confidenceIntervalChart = new Chart(ctx1, {
          type: "line",
          data: {
            labels: xValues,
            datasets: [
              {
                label: "Control (A) Posterior",
                data: controlDist,
                borderColor: "rgba(229, 62, 62, 0.8)",
                backgroundColor: "rgba(229, 62, 62, 0.1)",
                fill: true,
                tension: 0.4,
                borderWidth: 2,
              },
              {
                label: "Variant (B) Posterior",
                data: variantDist,
                borderColor: "rgba(56, 161, 105, 0.8)",
                backgroundColor: "rgba(56, 161, 105, 0.1)",
                fill: true,
                tension: 0.4,
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: true,
                text: "Posterior Probability Distributions",
                font: { size: 14, weight: "600" },
              },
              legend: {
                display: true,
                position: "bottom",
              },
              tooltip: {
                mode: "index",
                intersect: false,
              },
            },
            scales: {
              x: {
                title: {
                  display: true,
                  text: "Conversion Rate (%)",
                },
                ticks: {
                  maxTicksLimit: 10,
                  callback: function (value, index) {
                    return parseFloat(value).toFixed(1) + "%";
                  },
                },
              },
              y: {
                title: {
                  display: true,
                  text: "Probability Density",
                },
                beginAtZero: true,
              },
            },
          },
        });

        // 2. Probability Meter Chart
        const ctx2 = document
          .getElementById("comparisonChart")
          .getContext("2d");

        const probAWins = 1 - probBWins;

        comparisonChart = new Chart(ctx2, {
          type: "bar",
          data: {
            labels: ["Probability of Being Best"],
            datasets: [
              {
                label: "Control (A)",
                data: [probAWins * 100],
                backgroundColor: "rgba(229, 62, 62, 0.7)",
                borderColor: "rgba(229, 62, 62, 1)",
                borderWidth: 2,
              },
              {
                label: "Variant (B)",
                data: [probBWins * 100],
                backgroundColor: "rgba(56, 161, 105, 0.7)",
                borderColor: "rgba(56, 161, 105, 1)",
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: true,
                text: `Probability that Each Variant is Best`,
                font: { size: 14, weight: "600" },
              },
              legend: {
                display: true,
                position: "bottom",
              },
            },
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                title: {
                  display: true,
                  text: "Probability (%)",
                },
                ticks: {
                  callback: function (value) {
                    return value + "%";
                  },
                },
              },
            },
          },
        });
      }

      function createBayesianContinuousVisualizations(
        controlMean,
        controlStd,
        controlN,
        variantMean,
        variantStd,
        variantN,
        probBWins
      ) {
        // Destroy existing charts
        if (confidenceIntervalChart) confidenceIntervalChart.destroy();
        if (comparisonChart) comparisonChart.destroy();

        // 1. Posterior Distribution Chart
        const ctx1 = document
          .getElementById("confidenceIntervalChart")
          .getContext("2d");

        // Generate normal distribution curves for posteriors
        const controlSE = controlStd / Math.sqrt(controlN);
        const variantSE = variantStd / Math.sqrt(variantN);

        const minX = Math.min(controlMean - 3.5 * controlSE, variantMean - 3.5 * variantSE);
        const maxX = Math.max(controlMean + 3.5 * controlSE, variantMean + 3.5 * variantSE);

        const points = 200;
        const xValues = [];
        const controlDist = [];
        const variantDist = [];

        for (let i = 0; i <= points; i++) {
          const x = minX + (i / points) * (maxX - minX);
          xValues.push(x.toFixed(2));

          const controlPDF = normalPDF(x, controlMean, controlSE);
          const variantPDF = normalPDF(x, variantMean, variantSE);

          controlDist.push(controlPDF);
          variantDist.push(variantPDF);
        }

        confidenceIntervalChart = new Chart(ctx1, {
          type: "line",
          data: {
            labels: xValues,
            datasets: [
              {
                label: "Control (A) Posterior",
                data: controlDist,
                borderColor: "rgba(229, 62, 62, 0.8)",
                backgroundColor: "rgba(229, 62, 62, 0.1)",
                fill: true,
                tension: 0.4,
                borderWidth: 2,
              },
              {
                label: "Variant (B) Posterior",
                data: variantDist,
                borderColor: "rgba(56, 161, 105, 0.8)",
                backgroundColor: "rgba(56, 161, 105, 0.1)",
                fill: true,
                tension: 0.4,
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: true,
                text: "Posterior Probability Distributions",
                font: { size: 14, weight: "600" },
              },
              legend: {
                display: true,
                position: "bottom",
              },
              tooltip: {
                mode: "index",
                intersect: false,
              },
            },
            scales: {
              x: {
                title: {
                  display: true,
                  text: "Mean Value",
                },
                ticks: {
                  maxTicksLimit: 10,
                  callback: function (value, index) {
                    return parseFloat(value).toFixed(1);
                  },
                },
              },
              y: {
                title: {
                  display: true,
                  text: "Probability Density",
                },
                beginAtZero: true,
              },
            },
          },
        });

        // 2. Probability Meter Chart
        const ctx2 = document
          .getElementById("comparisonChart")
          .getContext("2d");

        const probAWins = 1 - probBWins;

        comparisonChart = new Chart(ctx2, {
          type: "bar",
          data: {
            labels: ["Probability of Being Best"],
            datasets: [
              {
                label: "Control (A)",
                data: [probAWins * 100],
                backgroundColor: "rgba(229, 62, 62, 0.7)",
                borderColor: "rgba(229, 62, 62, 1)",
                borderWidth: 2,
              },
              {
                label: "Variant (B)",
                data: [probBWins * 100],
                backgroundColor: "rgba(56, 161, 105, 0.7)",
                borderColor: "rgba(56, 161, 105, 1)",
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: true,
                text: `Probability that Each Variant is Best`,
                font: { size: 14, weight: "600" },
              },
              legend: {
                display: true,
                position: "bottom",
              },
            },
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                title: {
                  display: true,
                  text: "Probability (%)",
                },
                ticks: {
                  callback: function (value) {
                    return value + "%";
                  },
                },
              },
            },
          },
        });
      }

      // Helper function: Beta PDF
      function betaPDF(x, alpha, beta) {
        if (x <= 0 || x >= 1) return 0;

        // Use log space to avoid numerical overflow
        const logPDF = (alpha - 1) * Math.log(x) +
                       (beta - 1) * Math.log(1 - x) -
                       logBeta(alpha, beta);

        return Math.exp(logPDF);
      }

      // Helper function: Normal PDF
      function normalPDF(x, mean, stddev) {
        const exponent = -0.5 * Math.pow((x - mean) / stddev, 2);
        return Math.exp(exponent) / (stddev * Math.sqrt(2 * Math.PI));
      }

      function createContinuousVisualizations(
        controlMean,
        variantMean,
        controlStd,
        variantStd,
        lowerCI,
        upperCI,
        controlN,
        variantN
      ) {
        // Destroy existing charts
        if (confidenceIntervalChart) confidenceIntervalChart.destroy();
        if (comparisonChart) comparisonChart.destroy();

        // 1. Confidence Interval Chart - Forest Plot Style
        const ctx1 = document
          .getElementById("confidenceIntervalChart")
          .getContext("2d");
        const diff = variantMean - controlMean;

        confidenceIntervalChart = new Chart(ctx1, {
          type: "scatter",
          data: {
            datasets: [
              {
                label: "Mean Difference",
                data: [{ x: diff, y: 0.5 }],
                backgroundColor: diff > 0 ? "rgba(56, 161, 105, 0.8)" : "rgba(229, 62, 62, 0.8)",
                borderColor: diff > 0 ? "rgba(56, 161, 105, 1)" : "rgba(229, 62, 62, 1)",
                borderWidth: 2,
                pointRadius: 8,
                pointStyle: "circle",
              },
              {
                label: "95% Confidence Interval",
                data: [
                  { x: lowerCI, y: 0.5 },
                  { x: upperCI, y: 0.5 }
                ],
                showLine: true,
                borderColor: "rgba(102, 126, 234, 0.8)",
                borderWidth: 3,
                pointRadius: 0,
                fill: false,
              },
              {
                label: "No Effect Line",
                data: [
                  { x: 0, y: 0 },
                  { x: 0, y: 1 }
                ],
                showLine: true,
                borderColor: "rgba(0, 0, 0, 0.3)",
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: true,
                text: "Mean Difference with 95% Confidence Interval",
                font: { size: 14, weight: "600" },
              },
              legend: {
                display: true,
                position: "bottom",
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    if (context.datasetIndex === 0) {
                      return `Difference: ${diff.toFixed(2)} [${lowerCI.toFixed(2)}, ${upperCI.toFixed(2)}]`;
                    }
                    return '';
                  }
                }
              }
            },
            scales: {
              x: {
                title: {
                  display: true,
                  text: "Difference in Mean Value",
                },
              },
              y: {
                display: false,
                min: 0,
                max: 1,
              },
            },
          },
        });

        // 2. Comparison Chart with Error Bars
        const ctx2 = document
          .getElementById("comparisonChart")
          .getContext("2d");
        comparisonChart = new Chart(ctx2, {
          type: "bar",
          data: {
            labels: ["Control (A)", "Variant (B)"],
            datasets: [
              {
                label: "Mean Value",
                data: [controlMean, variantMean],
                backgroundColor: [
                  "rgba(229, 62, 62, 0.7)",
                  "rgba(56, 161, 105, 0.7)",
                ],
                borderColor: ["rgba(229, 62, 62, 1)", "rgba(56, 161, 105, 1)"],
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: true,
                text: "Mean Value Comparison (±1 SD)",
                font: { size: 14, weight: "600" },
              },
              legend: {
                display: false,
              },
              tooltip: {
                callbacks: {
                  afterLabel: function (context) {
                    const index = context.dataIndex;
                    const std = index === 0 ? controlStd : variantStd;
                    return `SD: ±${std.toFixed(2)}`;
                  },
                },
              },
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: "Mean Value",
                },
              },
            },
          },
        });
      }

      document.addEventListener("DOMContentLoaded", function () {
        const inputs = document.querySelectorAll("input");
        inputs.forEach((input) => {
          input.addEventListener("keypress", function (e) {
            if (e.key === "Enter") {
              analyzeResults();
            }
          });
        });

        // Initialize with conversion mode
        currentMetricType = "conversion";
      });
    </script>
  </body>
</html>
